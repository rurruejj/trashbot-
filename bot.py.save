import os
import asyncio
import json
import base64
import html
from aiogram import Bot, Dispatcher, F, types
from aiogram.client.default import DefaultBotProperties
from aiogram.types import Message, CallbackQuery, FSInputFile, WebAppInfo
from aiogram.filters import CommandStart, Command, CommandObject
from aiogram.utils.keyboard import InlineKeyboardBuilder
from aiogram.enums import ParseMode, ContentType

from db import (
    init_db, save_user_info, get_user_info, add_request,
    mark_request_completed, clear_all_data, get_user_id_by_request_id
)

# === –¥–æ–±–∞–≤–ª–µ–Ω–æ: HTTP —Å–µ—Ä–≤–µ—Ä –¥–ª—è –ø—Ä–æ—Ñ–∏–ª—è
from aiohttp import web

# ====== –ù–ê–°–¢–†–û–ô–ö–ò ======
BOT_TOKEN = os.getenv("BOT_TOKEN", "8278093306:AAFbhmogmEOS-wVYGSDbIW45jD5jcxSX3ZE")
try:
    ADMIN_ID = int(os.getenv("ADMIN_ID", "1851886180"))
except Exception:
    ADMIN_ID = 1851886180

CHANNEL_USERNAME = os.getenv("CHANNEL_USERNAME", "@udveri_ru")
WEBAPP_TARIFFS_URL = os.getenv("WEBAPP_URL", "https://udveri-tariffs.vercel.app/")
WEBAPP_VERSION = os.getenv("WEBAPP_VERSION", "2025-08-13-1")

PHOTO_PATHS = [
    ['photo1.jpg', '—Ñ–æ—Ç–æ1.jpg', '—Ñ–æ—Ç–æ 1.jpg', '–§–æ—Ç–æ 1.jpg', '1.jpg'],
    ['photo2.jpg', '—Ñ–æ—Ç–æ2.jpg', '—Ñ–æ—Ç–æ 2.jpg', '–§–æ—Ç–æ 2.jpg', '2.jpg'],
    ['photo3.jpg', '—Ñ–æ—Ç–æ3.jpg', '—Ñ–æ—Ç–æ 3.jpg', '–§–æ—Ç–æ 3.jpg', '3.jpg'],
    ['photo4.jpg', '—Ñ–æ—Ç–æ4.jpg', '—Ñ–æ—Ç–æ 4.jpg', '–§–æ—Ç–æ 4.jpg', '4.jpg'],
    ['photo5.jpg', '—Ñ–æ—Ç–æ5.jpg', '—Ñ–æ—Ç–æ 5.jpg', '–§–æ—Ç–æ 5.jpg', '5.jpg'],
]

INTRO_CAPTIONS = [
    "–ü–µ—Ä–≤–æ–µ –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ–µ —Ñ–æ—Ç–æ",
    "–í—Ç–æ—Ä–æ–µ –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ–µ —Ñ–æ—Ç–æ",
    "–¢—Ä–µ—Ç—å–µ –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ–µ —Ñ–æ—Ç–æ",
    "–ß–µ—Ç–≤—ë—Ä—Ç–æ–µ –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ–µ —Ñ–æ—Ç–æ",
    "–ü—è—Ç–æ–µ –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ–µ —Ñ–æ—Ç–æ"
]

# –ü–∞–º—è—Ç—å —Å–æ—Å—Ç–æ—è–Ω–∏–π/–≤–≤–æ–¥–∞ (–ø—Ä–æ—Å—Ç–∞—è FSM)
user_states = {}
user_data = {}

# ====== –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï ======
def _miniapp_url_for_user(user_id: int) -> str:
    info = get_user_info(user_id) or {}
    payload = {
        "user_id": user_id,
        "first_name": info.get("first_name") or "",
        "street": info.get("street") or "",
        "house": info.get("house") or "",
        "flat": info.get("flat") or "",
        "entrance": info.get("entrance") or "",
        "floor": info.get("floor") or "",
        "phone": info.get("phone") or "",
        "tab": "menu"
    }
    p = base64.urlsafe_b64encode(json.dumps(payload, ensure_ascii=False).encode()).decode()
    sep = "&" if "?" in WEBAPP_TARIFFS_URL else "?"
    return f"{WEBAPP_TARIFFS_URL}{sep}v={WEBAPP_VERSION}&p={p}"

def _tab_url(base_url: str, tab: str) -> str:
    sep = "&" if "?" in base_url else "?"
    return f"{base_url}{sep}tab={tab}"

def miniapp_kb_for(user_id: int) -> types.InlineKeyboardMarkup:
    base_url = _miniapp_url_for_user(user_id)
    kb = InlineKeyboardBuilder()
    kb.button(text="–û—Ç–∫—Ä—ã—Ç—å –º–∏–Ω–∏-–ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ", web_app=WebAppInfo(url=base_url))
    kb.button(text="–ó–∞—è–≤–∫–∞",  web_app=WebAppInfo(url=_tab_url(base_url, "request")))
    kb.button(text="–¢–∞—Ä–∏—Ñ—ã",  web_app=WebAppInfo(url=_tab_url(base_url, "tariffs")))
    kb.button(text="–ü—Ä–æ—Ñ–∏–ª—å", web_app=WebAppInfo(url=_tab_url(base_url, "profile")))
    return kb.as_markup()

def find_intro_photo(name_variants):
    for name in name_variants:
        path = os.path.join("media", name)
        if os.path.exists(path):
            return FSInputFile(path)
    return None

def _format_address(info: dict) -> str:
    parts = []
    if info.get("street"):   parts.append(info["street"])
    if info.get("house"):    parts.append(f"–¥.{info['house']}")
    if info.get("flat"):     parts.append(f"–∫–≤.{info['flat']}")
    if info.get("entrance"): parts.append(f"–ø–æ–¥—ä–µ–∑–¥ {info['entrance']}")
    if info.get("floor"):    parts.append(f"—ç—Ç–∞–∂ {info['floor']}")
    if info.get("city"):     parts.append(info["city"])
    return ", ".join(parts) if parts else "‚Äî"

def _format_user_link(u: types.User) -> str:
    if u.username:
        return f"@{u.username}"
    return f'<a href="tg://user?id={u.id}">{html.escape(u.first_name or "–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å")}</a>'

# ====== –•–≠–ù–î–õ–ï–†–´ ======
async def start_handler(message: Message, bot: Bot):
    user = message.from_user
    user_id = user.id
    try:
        save_user_info(
            user_id,
            first_name=user.first_name or "",
            last_name=user.last_name or "",
            username=user.username or ""
        )
    except Exception as e:
        print("save_user_info error:", e)

    info = get_user_info(user_id)
    if info and (info.get("street") or info.get("phone")):
        name = info.get('first_name') or user.first_name or ''
        await message.answer(
            f"–ü—Ä–∏–≤–µ—Ç, {name}! –†–∞–¥ —Å–Ω–æ–≤–∞ –≤–∏–¥–µ—Ç—å —Ç–µ–±—è üëã",
            reply_markup=miniapp_kb_for(user_id)
        )
        return

    user_states[user_id] = {"step": 0}
    await send_intro_photo(bot, user_id, 0)

async def webapp_entry(message: Message, bot: Bot):
    kb = InlineKeyboardBuilder()
    kb.button(text="–û—Ç–∫—Ä—ã—Ç—å –º–∏–Ω–∏-–ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ", web_app=WebAppInfo(url=_miniapp_url_for_user(message.from_user.id)))
    await message.answer("–û—Ç–∫—Ä–æ–π –º–∏–Ω–∏-–ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –∫–Ω–æ–ø–∫–æ–π –Ω–∏–∂–µ:", reply_markup=kb.as_markup())

async def send_intro_photo(bot: Bot, user_id: int, idx: int):
    if idx < 0 or idx >= len(PHOTO_PATHS):
        idx = 0
    photo = find_intro_photo(PHOTO_PATHS[idx])
    caption = INTRO_CAPTIONS[idx] if idx < len(INTRO_CAPTIONS) else ""
    kb = InlineKeyboardBuilder()
    if idx < len(PHOTO_PATHS) - 1:
        kb.button(text="–î–∞–ª–µ–µ ‚û°Ô∏è", callback_data=f"next:{idx+1}")
    else:
        kb.button(text="–ü–µ—Ä–µ–π—Ç–∏ –∫ —Å–æ–≥–ª–∞—Å–∏—é", callback_data="pd")
    if photo:
        await bot.send_photo(user_id, photo, caption=caption, parse_mode=ParseMode.HTML, reply_markup=kb.as_markup())
    else:
        await bot.send_message(user_id, caption, reply_markup=kb.as_markup())

async def next_photo(callback: CallbackQuery, bot: Bot):
    try:
        idx = int(callback.data.split(":")[1])
    except Exception:
        idx = 0
    await callback.answer()
    await send_intro_photo(bot, callback.from_user.id, idx)

async def show_pd(callback: CallbackQuery, bot: Bot):
    await callback.answer()
    kb = InlineKeyboardBuilder()
    kb.button(text="‚úÖ –°–æ–≥–ª–∞—Å–µ–Ω", callback_data="pd_ok")
    await bot.send_message(callback.from_user.id, "üõ°Ô∏è –°–æ–≥–ª–∞—Å–∏–µ –Ω–∞ –æ–±—Ä–∞–±–æ—Ç–∫—É –ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö", reply_markup=kb.as_markup())

async def pd_ok(callback: CallbackQuery, bot: Bot):
    await callback.answer()
    user_states[callback.from_user.id] = {"step": "street"}
    await bot.send_message(callback.from_user.id, "üè† –í–≤–µ–¥–∏—Ç–µ —É–ª–∏—Ü—É:")

async def text_handler(message: Message, bot: Bot):
    user_id = message.from_user.id
    if user_id not in user_states:
        return
    step = user_states[user_id].get("step")

    if step == "street":
        user_data[user_id] = {"street": message.text.strip()}
        user_states[user_id]["step"] = "house"
        await message.answer("–í–≤–µ–¥–∏—Ç–µ –Ω–æ–º–µ—Ä –¥–æ–º–∞:")
    elif step == "house":
        user_data[user_id]["house"] = message.text.strip()
        user_states[user_id]["step"] = "flat"
        await message.answer("–í–≤–µ–¥–∏—Ç–µ –Ω–æ–º–µ—Ä –∫–≤–∞—Ä—Ç–∏—Ä—ã:")
    elif step == "flat":
        user_data[user_id]["flat"] = message.text.strip()
        user_states[user_id]["step"] = "entrance"
        await message.answer("–í–≤–µ–¥–∏—Ç–µ –ø–æ–¥—ä–µ–∑–¥:")
    elif step == "entrance":
        user_data[user_id]["entrance"] = message.text.strip()
        user_states[user_id]["step"] = "floor"
        await message.answer("–í–≤–µ–¥–∏—Ç–µ —ç—Ç–∞–∂:")
    elif step == "floor":
        user_data[user_id]["floor"] = message.text.strip()
        user_states[user_id]["step"] = "phone"
        await message.answer("–í–≤–µ–¥–∏—Ç–µ —Ç–µ–ª–µ—Ñ–æ–Ω:")
    elif step == "phone":
        user_data[user_id]["phone"] = message.text.strip()
        save_user_info(user_id, **user_data[user_id])
        user_states.pop(user_id, None)
        user_data.pop(user_id, None)
        await message.answer("‚úÖ –ê–¥—Ä–µ—Å —Å–æ—Ö—Ä–∞–Ω—ë–Ω. –û—Ç–∫—Ä—ã–≤–∞–π—Ç–µ –º–µ–Ω—é:", reply_markup=miniapp_kb_for(user_id))

# === –ü–†–ò–Å–ú –î–ê–ù–ù–´–• –ò–ó –ú–ò–ù–ò-–ê–ü–ü–ê + DEBUG ===
async def webapp_data_handler(message: Message, bot: Bot):
    # –õ–û–ì–ò –í –ö–û–ù–°–û–õ–¨
    try:
        raw = message.web_app_data.data if message.web_app_data else None
    except Exception:
        raw = None

    print("üì© WEB_APP_DATA raw:", repr(raw))

    # –õ—ë–≥–∫–∏–π –¥–µ–±–∞–≥ –≤ –ª–∏—á–∫—É –∞–¥–º–∏–Ω—É
    try:
        if raw:
            preview = html.escape(raw[:1000])
            await bot.send_message(
                ADMIN_ID,
                f"üß™ <b>DEBUG</b> web_app_data:\n<code>{preview}</code>",
                parse_mode=ParseMode.HTML
            )
    except Exception as e:
        print("DEBUG send admin error:", e)

    if not raw:
        return

    # –ü–∞—Ä—Å–∏–º JSON
    try:
        data = json.loads(raw)
        if not isinstance(data, dict):
            raise ValueError("web_app_data is not a JSON object")
    except Exception as e:
        print("‚ùå –û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ WebAppData:", e)
        return

    # –ü–∏–Ω–≥ —Å –≤–∫–ª–∞–¥–∫–∏ ¬´–ü—Ä–æ—Ñ–∏–ª—å¬ª
    if data.get("type") == "ping_profile":
        await message.answer("–ü—Ä–∏–≤–µ—Ç! (–∏–∑ –º–∏–Ω–∏-–∞–ø–ø–∞)")
        return

    # –°–æ–∑–¥–∞–Ω–∏–µ –∑–∞—è–≤–∫–∏
    if data.get("type") == "create_request":
        def _get_first(d: dict, keys, default=None):
            for k in keys:
                if k in d and d[k] not in (None, ""):
                    return d[k]
            return default

        bags_raw = _get_first(data, ["bags", "count", "qty", "quantity"], 1)
        try:
            bags = int(bags_raw)
            if bags < 1:
                bags = 1
        except Exception:
            bags = 1

        comment = str(_get_first(data, ["comment", "note", "text"], "")).strip()

        try:
            request_id = add_request(message.from_user.id, bags, comment)
        except Exception as e:
            print("‚ùå –û—à–∏–±–∫–∞ add_request:", e)
            await message.answer("‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –∑–∞—è–≤–∫–∏, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑.")
            return

        u = message.from_user
        info = get_user_info(u.id) or {}
        addr  = _format_address(info)
        phone = info.get("phone") or "‚Äî"
        uname = _format_user_link(u)

        admin_text = (
            "üß∫ <b>–ó–∞—è–≤–∫–∞</b>\n"
            f"–ü–∞–∫–µ—Ç—ã: <b>{bags}</b>\n"
            f"–ê–¥—Ä–µ—Å: {addr}\n"
            f"–¢–µ–ª–µ—Ñ–æ–Ω: {phone}\n"
            f"–Æ–∑–µ—Ä–Ω–µ–π–º: {uname}"
        )

        kb = InlineKeyboardBuilder()
        kb.button(text="‚úÖ –ó–∞–±—Ä–∞–ª –º—É—Å–æ—Ä", callback_data=f"complete:{request_id}")

        try:
            await bot.send_message(
                ADMIN_ID,
                admin_text,
                parse_mode=ParseMode.HTML,
                reply_markup=kb.as_markup()
            )
            await message.answer("‚úÖ –ó–∞—è–≤–∫–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.")
        except Exception as e:
            print("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –∞–¥–º–∏–Ω—É:", e)
        return

async def complete_request(callback: CallbackQuery, bot: Bot):
    try:
        parts = callback.data.split(":")
        if len(parts) != 2:
            return
        request_id = int(parts[1])

        mark_request_completed(request_id)
        await callback.answer("–ó–∞—è–≤–∫–∞ –æ—Ç–º–µ—á–µ–Ω–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–Ω–æ–π ‚úÖ")

        user_id = get_user_id_by_request_id(request_id)
        if user_id:
            try:
                await bot.send_message(user_id, "‚úÖ –í–∞—à–∞ –∑–∞—è–≤–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∞. –ú—É—Å–æ—Ä –≤—ã–Ω–µ—Å–µ–Ω.")
            except Exception:
                pass

        try:
            await bot.edit_message_reply_markup(
                chat_id=callback.message.chat.id,
                message_id=callback.message.message_id,
                reply_markup=None
            )
        except Exception:
            pass

    except Exception as e:
        print("complete_request error:", e)

async def clear_command_handler(message: Message, bot: Bot):
    if message.from_user.id != ADMIN_ID:
        await message.answer("‚õîÔ∏è –£ –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–π –∫–æ–º–∞–Ω–¥–µ.")
        return

    clear_all_data()
    user_states.clear()
    user_data.clear()
    await message.answer("‚úÖ –í—Å–µ –¥–∞–Ω–Ω—ã–µ –æ—á–∏—â–µ–Ω—ã. –í—Å–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ –Ω–∞—á–Ω—É—Ç —Å –Ω–∞—á–∞–ª–∞.")

# ====== –¢–ï–°–¢–û–í–´–ï –ö–û–ú–ê–ù–î–´ –î–õ–Ø –ü–†–û–í–ï–†–ö–ò –ë–î ======
async def db_test(message: Message, bot: Bot):
    from db import DB_NAME
    import os
    await message.answer(f"üóÑÔ∏è DB path: <code>{os.path.abspath(DB_NAME)}</code>", parse_mode=ParseMode.HTML)
    rid = add_request(message.from_user.id, 1, "DB self-test")
    await message.answer(f"‚úÖ DB self-test ok, id={rid}")

async def force_request(message: Message, bot: Bot, command: CommandObject):
    # /req 3 —Ç–µ—Å—Ç–æ–≤—ã–π –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π
    args = (command.args or "").strip()
    if not args:
        await message.answer("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /req <–∫–æ–ª-–≤–æ> <–∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π>")
        return
    try:
        parts = args.split(" ", 1)
        bags = int(parts[0])
        comment = parts[1] if len(parts) > 1 else ""
    except Exception:
        bags, comment = 1, args

    rid = add_request(message.from_user.id, bags, comment)

    info = get_user_info(message.from_user.id) or {}
    addr = _format_address(info)
    phone = info.get("phone") or "‚Äî"
    uname = _format_user_link(message.from_user)

    admin_text = (
        "üß∫ <b>–ó–∞—è–≤–∫–∞</b>\n"
        f"–ü–∞–∫–µ—Ç—ã: <b>{bags}</b>\n"
        f"–ê–¥—Ä–µ—Å: {addr}\n"
        f"–¢–µ–ª–µ—Ñ–æ–Ω: {phone}\n"
        f"–Æ–∑–µ—Ä–Ω–µ–π–º: {uname}"
    )
    kb = InlineKeyboardBuilder()
    kb.button(text="‚úÖ –ó–∞–±—Ä–∞–ª –º—É—Å–æ—Ä", callback_data=f"complete:{rid}")
    await bot.send_message(ADMIN_ID, admin_text, parse_mode=ParseMode.HTML, reply_markup=kb.as_markup())
    await message.answer(f"–°–æ–∑–¥–∞–Ω–∞ —Ç–µ—Å—Ç-–∑–∞—è–≤–∫–∞ #{rid} –∏ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ –∞–¥–º–∏–Ω—É.")

# === –î–û–ë–ê–í–õ–ï–ù–û: HTTP —ç–Ω–¥–ø–æ–∏–Ω—Ç –¥–ª—è –ø—Ä–æ—Ñ–∏–ª—è ===
async def http_get_user(request: web.Request):
    user_id_raw = request.query.get("user_id")
    try:
        user_id = int(user_id_raw)
    except Exception:
        return web.json_response({"ok": False, "error": "bad user_id"}, status=400)

    info = get_user_info(user_id) or {}
    name = ((info.get("first_name") or "") + (" " + info.get("last_name") if info.get("last_name") else "")).strip()
    if not name:
        name = "‚Äî"
    username = info.get("username") or "‚Äî"
    phone = info.get("phone") or "‚Äî"
    address = _format_address(info)

    return web.json_response({
        "ok": True,
        "profile": {
            "name": name,
            "username": username,
            "phone": phone,
            "address": address
        }
    })

# ====== –¢–û–ß–ö–ê –í–•–û–î–ê ======
async def main():
    init_db()
    bot = Bot(token=BOT_TOKEN, default=DefaultBotProperties(parse_mode=ParseMode.HTML))
    dp = Dispatcher()

    dp.message.register(start_handler, CommandStart())
    dp.message.register(clear_command_handler, Command("clear"))
    dp.message.register(webapp_entry, Command("webapp"))

    # —Ç–µ—Å—Ç—ã –ë–î
    dp.message.register(db_test, Command("dbtest"))
    dp.message.register(force_request, Command("req"))

    dp.callback_query.register(next_photo, F.data.startswith("next:"))
    dp.callback_query.register(show_pd, F.data == "pd")
    dp.callback_query.register(pd_ok, F.data == "pd_ok")

    # –û–ë–Ø–ó–ê–¢–ï–õ–¨–ù–û: web_app_data –¥–æ text_handler
    dp.message.register(webapp_data_handler, F.web_app_data)
    dp.message.register(webapp_data_handler, F.content_type == ContentType.WEB_APP_DATA)

    dp.message.register(text_handler, F.text)

    # –ª–æ–≤—É—à–∫–∞ –ª—é–±–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è ‚Äî –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞
    async def _dbg_any_message(message: Message):
        try:
            print("üêû ANY MESSAGE:", message.content_type)
            if getattr(message, "web_app_data", None):
                print("üêû web_app_data present:", repr(message.web_app_data.data))
        except Exception as e:
            print("üêû dbg error:", e)
    dp.message.register(_dbg_any_message)  # –ø–æ—Å–ª–µ —Ü–µ–ª–µ–≤—ã—Ö

    dp.callback_query.register(complete_request, F.data.startswith("complete:"))

    # === –î–û–ë–ê–í–õ–ï–ù–û: –ø–æ–¥–Ω–∏–º–∞–µ–º HTTP-—Å–µ—Ä–≤–µ—Ä
    app = web.Application()
    app.router.add_get("/get_user", http_get_user)
    runner = web.AppRunner(app)
    await runner.setup()
    http_port = int(os.getenv("BOT_HTTP_PORT", "8000"))
    site = web.TCPSite(runner, "0.0.0.0", http_port)
    await site.start()
    print(f"HTTP server started on http://0.0.0.0:{http_port}")

    await dp.start_polling(bot)

if __name__ == "__main__":
    asyncio.run(main())
import os
import asyncio
import json
import base64
import html
from aiogram import Bot, Dispatcher, F, types
from aiogram.client.default import DefaultBotProperties
from aiogram.types import Message, CallbackQuery, FSInputFile, WebAppInfo
from aiogram.filters import CommandStart, Command, CommandObject
from aiogram.utils.keyboard import InlineKeyboardBuilder
from aiogram.enums import ParseMode, ContentType

from db import (
    init_db, save_user_info, get_user_info, add_request,
    mark_request_completed, clear_all_data, get_user_id_by_request_id
)

# ====== –ù–ê–°–¢–†–û–ô–ö–ò ======
BOT_TOKEN = os.getenv("BOT_TOKEN", "8278093306:AAFbhmogmEOS-wVYGSDbIW45jD5jcxSX3ZE")
try:
    ADMIN_ID = int(os.getenv("ADMIN_ID", "1851886180"))
except Exception:
    ADMIN_ID = 1851886180

CHANNEL_USERNAME = os.getenv("CHANNEL_USERNAME", "@udveri_ru")
WEBAPP_TARIFFS_URL = os.getenv("WEBAPP_URL", "https://udveri-tariffs.vercel.app/")
WEBAPP_VERSION = os.getenv("WEBAPP_VERSION", "2025-08-13-1")

PHOTO_PATHS = [
    ['photo1.jpg', '—Ñ–æ—Ç–æ1.jpg', '—Ñ–æ—Ç–æ 1.jpg', '–§–æ—Ç–æ 1.jpg', '1.jpg'],
    ['photo2.jpg', '—Ñ–æ—Ç–æ2.jpg', '—Ñ–æ—Ç–æ 2.jpg', '–§–æ—Ç–æ 2.jpg', '2.jpg'],
    ['photo3.jpg', '—Ñ–æ—Ç–æ3.jpg', '—Ñ–æ—Ç–æ 3.jpg', '–§–æ—Ç–æ 3.jpg', '3.jpg'],
    ['photo4.jpg', '—Ñ–æ—Ç–æ4.jpg', '—Ñ–æ—Ç–æ 4.jpg', '–§–æ—Ç–æ 4.jpg', '4.jpg'],
    ['photo5.jpg', '—Ñ–æ—Ç–æ5.jpg', '—Ñ–æ—Ç–æ 5.jpg', '–§–æ—Ç–æ 5.jpg', '5.jpg'],
]

INTRO_CAPTIONS = [
    "–ü–µ—Ä–≤–æ–µ –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ–µ —Ñ–æ—Ç–æ",
    "–í—Ç–æ—Ä–æ–µ –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ–µ —Ñ–æ—Ç–æ",
    "–¢—Ä–µ—Ç—å–µ –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ–µ —Ñ–æ—Ç–æ",
    "–ß–µ—Ç–≤—ë—Ä—Ç–æ–µ –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ–µ —Ñ–æ—Ç–æ",
    "–ü—è—Ç–æ–µ –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ–µ —Ñ–æ—Ç–æ"
]

# –ü–∞–º—è—Ç—å —Å–æ—Å—Ç–æ—è–Ω–∏–π/–≤–≤–æ–¥–∞ (–ø—Ä–æ—Å—Ç–∞—è FSM)
user_states = {}
user_data = {}

# ====== –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï ======
def _miniapp_url_for_user(user_id: int) -> str:
    info = get_user_info(user_id) or {}
    payload = {
        "user_id": user_id,
        "first_name": info.get("first_name") or "",
        "street": info.get("street") or "",
        "house": info.get("house") or "",
        "flat": info.get("flat") or "",
        "entrance": info.get("entrance") or "",
        "floor": info.get("floor") or "",
        "phone": info.get("phone") or "",
        "tab": "menu"
    }
    p = base64.urlsafe_b64encode(json.dumps(payload, ensure_ascii=False).encode()).decode()
    sep = "&" if "?" in WEBAPP_TARIFFS_URL else "?"
    return f"{WEBAPP_TARIFFS_URL}{sep}v={WEBAPP_VERSION}&p={p}"

def _tab_url(base_url: str, tab: str) -> str:
    sep = "&" if "?" in base_url else "?"
    return f"{base_url}{sep}tab={tab}"

def miniapp_kb_for(user_id: int) -> types.InlineKeyboardMarkup:
    base_url = _miniapp_url_for_user(user_id)
    kb = InlineKeyboardBuilder()
    kb.button(text="–û—Ç–∫—Ä—ã—Ç—å –º–∏–Ω–∏-–ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ", web_app=WebAppInfo(url=base_url))
    kb.button(text="–ó–∞—è–≤–∫–∞",  web_app=WebAppInfo(url=_tab_url(base_url, "request")))
    kb.button(text="–¢–∞—Ä–∏—Ñ—ã",  web_app=WebAppInfo(url=_tab_url(base_url, "tariffs")))
    kb.button(text="–ü—Ä–æ—Ñ–∏–ª—å", web_app=WebAppInfo(url=_tab_url(base_url, "profile")))
    return kb.as_markup()

def find_intro_photo(name_variants):
    for name in name_variants:
        path = os.path.join("media", name)
        if os.path.exists(path):
            return FSInputFile(path)
    return None

def _format_address(info: dict) -> str:
    parts = []
    if info.get("street"):   parts.append(info["street"])
    if info.get("house"):    parts.append(f"–¥.{info['house']}")
    if info.get("flat"):     parts.append(f"–∫–≤.{info['flat']}")
    if info.get("entrance"): parts.append(f"–ø–æ–¥—ä–µ–∑–¥ {info['entrance']}")
    if info.get("floor"):    parts.append(f"—ç—Ç–∞–∂ {info['floor']}")
    if info.get("city"):     parts.append(info["city"])
    return ", ".join(parts) if parts else "‚Äî"

def _format_user_link(u: types.User) -> str:
    if u.username:
        return f"@{u.username}"
    return f'<a href="tg://user?id={u.id}">{html.escape(u.first_name or "–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å")}</a>'

# ====== –•–≠–ù–î–õ–ï–†–´ ======
async def start_handler(message: Message, bot: Bot):
    user = message.from_user
    user_id = user.id
    try:
        save_user_info(
            user_id,
            first_name=user.first_name or "",
            last_name=user.last_name or "",
            username=user.username or ""
        )
    except Exception as e:
        print("save_user_info error:", e)

    info = get_user_info(user_id)
    if info and (info.get("street") or info.get("phone")):
        name = info.get('first_name') or user.first_name or ''
        await message.answer(
            f"–ü—Ä–∏–≤–µ—Ç, {name}! –†–∞–¥ —Å–Ω–æ–≤–∞ –≤–∏–¥–µ—Ç—å —Ç–µ–±—è üëã",
            reply_markup=miniapp_kb_for(user_id)
        )
        return

    user_states[user_id] = {"step": 0}
    await send_intro_photo(bot, user_id, 0)

async def webapp_entry(message: Message, bot: Bot):
    kb = InlineKeyboardBuilder()
    kb.button(text="–û—Ç–∫—Ä—ã—Ç—å –º–∏–Ω–∏-–ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ", web_app=WebAppInfo(url=_miniapp_url_for_user(message.from_user.id)))
    await message.answer("–û—Ç–∫—Ä–æ–π –º–∏–Ω–∏-–ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –∫–Ω–æ–ø–∫–æ–π –Ω–∏–∂–µ:", reply_markup=kb.as_markup())

async def send_intro_photo(bot: Bot, user_id: int, idx: int):
    if idx < 0 or idx >= len(PHOTO_PATHS):
        idx = 0
    photo = find_intro_photo(PHOTO_PATHS[idx])
    caption = INTRO_CAPTIONS[idx] if idx < len(INTRO_CAPTIONS) else ""
    kb = InlineKeyboardBuilder()
    if idx < len(PHOTO_PATHS) - 1:
        kb.button(text="–î–∞–ª–µ–µ ‚û°Ô∏è", callback_data=f"next:{idx+1}")
    else:
        kb.button(text="–ü–µ—Ä–µ–π—Ç–∏ –∫ —Å–æ–≥–ª–∞—Å–∏—é", callback_data="pd")
    if photo:
        await bot.send_photo(user_id, photo, caption=caption, parse_mode=ParseMode.HTML, reply_markup=kb.as_markup())
    else:
        await bot.send_message(user_id, caption, reply_markup=kb.as_markup())

async def next_photo(callback: CallbackQuery, bot: Bot):
    try:
        idx = int(callback.data.split(":")[1])
    except Exception:
        idx = 0
    await callback.answer()
    await send_intro_photo(bot, callback.from_user.id, idx)

async def show_pd(callback: CallbackQuery, bot: Bot):
    await callback.answer()
    kb = InlineKeyboardBuilder()
    kb.button(text="‚úÖ –°–æ–≥–ª–∞—Å–µ–Ω", callback_data="pd_ok")
    await bot.send_message(callback.from_user.id, "üõ°Ô∏è –°–æ–≥–ª–∞—Å–∏–µ –Ω–∞ –æ–±—Ä–∞–±–æ—Ç–∫—É –ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö", reply_markup=kb.as_markup())

async def pd_ok(callback: CallbackQuery, bot: Bot):
    await callback.answer()
    user_states[callback.from_user.id] = {"step": "street"}
    await bot.send_message(callback.from_user.id, "üè† –í–≤–µ–¥–∏—Ç–µ —É–ª–∏—Ü—É:")

async def text_handler(message: Message, bot: Bot):
    user_id = message.from_user.id
    if user_id not in user_states:
        return
    step = user_states[user_id].get("step")

    if step == "street":
        user_data[user_id] = {"street": message.text.strip()}
        user_states[user_id]["step"] = "house"
        await message.answer("–í–≤–µ–¥–∏—Ç–µ –Ω–æ–º–µ—Ä –¥–æ–º–∞:")
    elif step == "house":
        user_data[user_id]["house"] = message.text.strip()
        user_states[user_id]["step"] = "flat"
        await message.answer("–í–≤–µ–¥–∏—Ç–µ –Ω–æ–º–µ—Ä –∫–≤–∞—Ä—Ç–∏—Ä—ã:")
    elif step == "flat":
        user_data[user_id]["flat"] = message.text.strip()
        user_states[user_id]["step"] = "entrance"
        await message.answer("–í–≤–µ–¥–∏—Ç–µ –ø–æ–¥—ä–µ–∑–¥:")
    elif step == "entrance":
        user_data[user_id]["entrance"] = message.text.strip()
        user_states[user_id]["step"] = "floor"
        await message.answer("–í–≤–µ–¥–∏—Ç–µ —ç—Ç–∞–∂:")
    elif step == "floor":
        user_data[user_id]["floor"] = message.text.strip()
        user_states[user_id]["step"] = "phone"
        await message.answer("–í–≤–µ–¥–∏—Ç–µ —Ç–µ–ª–µ—Ñ–æ–Ω:")
    elif step == "phone":
        user_data[user_id]["phone"] = message.text.strip()
        save_user_info(user_id, **user_data[user_id])
        user_states.pop(user_id, None)
        user_data.pop(user_id, None)
        await message.answer("‚úÖ –ê–¥—Ä–µ—Å —Å–æ—Ö—Ä–∞–Ω—ë–Ω. –û—Ç–∫—Ä—ã–≤–∞–π—Ç–µ –º–µ–Ω—é:", reply_markup=miniapp_kb_for(user_id))

# === –ü–†–ò–Å–ú –î–ê–ù–ù–´–• –ò–ó –ú–ò–ù–ò-–ê–ü–ü–ê + DEBUG ===
async def webapp_data_handler(message: Message, bot: Bot):
    try:
        raw = message.web_app_data.data if message.web_app_data else None
    except Exception:
        raw = None

    print("üì© WEB_APP_DATA raw:", repr(raw))

    if not raw:
        return

    try:
        data = json.loads(raw)
        if not isinstance(data, dict):
            raise ValueError("web_app_data is not a JSON object")
    except Exception as e:
        print("‚ùå –û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ WebAppData:", e)
        return

    if data.get("type") == "ping_profile":
        await message.answer("–ü—Ä–∏–≤–µ—Ç! (–∏–∑ –º–∏–Ω–∏-–∞–ø–ø–∞)")
        return

    if data.get("type") == "create_request":
        def _get_first(d: dict, keys, default=None):
            for k in keys:
                if k in d and d[k] not in (None, ""):
                    return d[k]
            return default

        bags_raw = _get_first(data, ["bags", "count", "qty", "quantity"], 1)
        try:
            bags = int(bags_raw)
            if bags < 1:
                bags = 1
        except Exception:
            bags = 1

        comment = str(_get_first(data, ["comment", "note", "text"], "")).strip()

        try:
            request_id = add_request(message.from_user.id, bags, comment)
        except Exception as e:
            print("‚ùå –û—à–∏–±–∫–∞ add_request:", e)
            await message.answer("‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –∑–∞—è–≤–∫–∏, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑.")
            return

        u = message.from_user
        info = get_user_info(u.id) or {}
        addr  = _format_address(info)
        phone = info.get("phone") or "‚Äî"
        uname = _format_user_link(u)

        admin_text = (
            "üß∫ <b>–ó–∞—è–≤–∫–∞</b>\n"
            f"–ü–∞–∫–µ—Ç—ã: <b>{bags}</b>\n"
            f"–ê–¥—Ä–µ—Å: {addr}\n"
            f"–¢–µ–ª–µ—Ñ–æ–Ω: {phone}\n"
            f"–Æ–∑–µ—Ä–Ω–µ–π–º: {uname}"
        )

        kb = InlineKeyboardBuilder()
        kb.button(text="‚úÖ –ó–∞–±—Ä–∞–ª –º—É—Å–æ—Ä", callback_data=f"complete:{request_id}")

        try:
            # üî• –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∞–¥–º–∏–Ω—É
            await bot.send_message(
                ADMIN_ID,
                admin_text,
                parse_mode=ParseMode.HTML,
                reply_markup=kb.as_markup()
            )
            # üî• –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
            await message.answer("‚úÖ –ó–∞—è–≤–∫–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.")
        except Exception as e:
            print("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –∞–¥–º–∏–Ω—É:", e)
        return

async def complete_request(callback: CallbackQuery, bot: Bot):
    try:
        parts = callback.data.split(":")
        if len(parts) != 2:
            return
        request_id = int(parts[1])

        mark_request_completed(request_id)
        await callback.answer("–ó–∞—è–≤–∫–∞ –æ—Ç–º–µ—á–µ–Ω–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–Ω–æ–π ‚úÖ")

        user_id = get_user_id_by_request_id(request_id)
        if user_id:
            try:
                await bot.send_message(user_id, "‚úÖ –í–∞—à–∞ –∑–∞—è–≤–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∞. –ú—É—Å–æ—Ä –≤—ã–Ω–µ—Å–µ–Ω.")
            except Exception:
                pass

        try:
            await bot.edit_message_reply_markup(
                chat_id=callback.message.chat.id,
                message_id=callback.message.message_id,
                reply_markup=None
            )
        except Exception:
            pass

    except Exception as e:
        print("complete_request error:", e)

async def clear_command_handler(message: Message, bot: Bot):
    if message.from_user.id != ADMIN_ID:
        await message.answer("‚õîÔ∏è –£ –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–π –∫–æ–º–∞–Ω–¥–µ.")
        return

    clear_all_data()
    user_states.clear()
    user_data.clear()
    await message.answer("‚úÖ –í—Å–µ –¥–∞–Ω–Ω—ã–µ –æ—á–∏—â–µ–Ω—ã. –í—Å–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ –Ω–∞—á–Ω—É—Ç —Å –Ω–∞—á–∞–ª–∞.")

# ====== –¢–ï–°–¢–û–í–´–ï –ö–û–ú–ê–ù–î–´ ======
async def db_test(message: Message, bot: Bot):
    from db import DB_NAME
    import os
    await message.answer(f"üóÑÔ∏è DB path: <code>{os.path.abspath(DB_NAME)}</code>", parse_mode=ParseMode.HTML)
    rid = add_request(message.from_user.id, 1, "DB self-test")
    await message.answer(f"‚úÖ DB self-test ok, id={rid}")

async def force_request(message: Message, bot: Bot, command: CommandObject):
    args = (command.args or "").strip()
    if not args:
        await message.answer("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /req <–∫–æ–ª-–≤–æ> <–∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π>")
        return
    try:
        parts = args.split(" ", 1)
        bags = int(parts[0])
        comment = parts[1] if len(parts) > 1 else ""
    except Exception:
        bags, comment = 1, args

    rid = add_request(message.from_user.id, bags, comment)

    info = get_user_info(message.from_user.id) or {}
    addr = _format_address(info)
    phone = info.get("phone") or "‚Äî"
    uname = _format_user_link(message.from_user)

    admin_text = (
        "üß∫ <b>–ó–∞—è–≤–∫–∞</b>\n"
        f"–ü–∞–∫–µ—Ç—ã: <b>{bags}</b>\n"
        f"–ê–¥—Ä–µ—Å: {addr}\n"
        f"–¢–µ–ª–µ—Ñ–æ–Ω: {phone}\n"
        f"–Æ–∑–µ—Ä–Ω–µ–π–º: {uname}"
    )
    kb = InlineKeyboardBuilder()
    kb.button(text="‚úÖ –ó–∞–±—Ä–∞–ª –º—É—Å–æ—Ä", callback_data=f"complete:{rid}")
    await bot.send_message(ADMIN_ID, admin_text, parse_mode=ParseMode.HTML, reply_markup=kb.as_markup())
    await message.answer(f"–°–æ–∑–¥–∞–Ω–∞ —Ç–µ—Å—Ç-–∑–∞—è–≤–∫–∞ #{rid} –∏ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ –∞–¥–º–∏–Ω—É.")

# ====== –¢–û–ß–ö–ê –í–•–û–î–ê ======
async def main():
    init_db()
    bot = Bot(token=BOT_TOKEN, default=DefaultBotProperties(parse_mode=ParseMode.HTML))
    dp = Dispatcher()

    dp.message.register(start_handler, CommandStart())
    dp.message.register(clear_command_handler, Command("clear"))
    dp.message.register(webapp_entry, Command("webapp"))

    dp.message.register(db_test, Command("dbtest"))
    dp.message.register(force_request, Command("req"))

    dp.callback_query.register(next_photo, F.data.startswith("next:"))
    dp.callback_query.register(show_pd, F.data == "pd")
    dp.callback_query.register(pd_ok, F.data == "pd_ok")

    dp.message.register(webapp_data_handler, F.content_type == ContentType.WEB_APP_DATA)

    dp.message.register(text_handler, F.text)

    async def _dbg_any_message(message: Message):
        try:
            print("üêû ANY MESSAGE:", message.content_type)
            if getattr(message, "web_app_data", None):
                print("üêû web_app_data present:", repr(message.web_app_data.data))
        except Exception as e:
            print("üêû dbg error:", e)
    dp.message.register(_dbg_any_message)

    dp.callback_query.register(complete_request, F.data.startswith("complete:"))

    await dp.start_polling(bot)

if __name__ == "__main__":
    asyncio.run(main())

